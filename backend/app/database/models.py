"""
SQLAlchemy 2.0 Database Models
Following October 2025 best practices
"""
import uuid
from datetime import datetime
from typing import Optional

from sqlalchemy import DateTime, String, Integer, Text, JSON, func
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column


# ============================================================================
# Declarative Base
# ============================================================================

class Base(DeclarativeBase):
    """
    Base class for all SQLAlchemy models.
    Uses SQLAlchemy 2.0 DeclarativeBase pattern.
    """
    pass


# ============================================================================
# Mixins (Reusable Model Components)
# ============================================================================

class UUIDPrimaryKeyMixin:
    """
    Mixin for UUID primary key with server-side generation.

    Uses uuid4() for client-side default and PostgreSQL's gen_random_uuid()
    for server-side generation to ensure unique IDs even if application fails.
    """
    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
        comment="Unique identifier (UUID v4)"
    )


class TimestampMixin:
    """
    Mixin for created_at and updated_at timestamp columns.

    Uses PostgreSQL's CURRENT_TIMESTAMP for server-side generation.
    updated_at automatically updates on row modification.
    """
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
        comment="Timestamp when record was created"
    )

    updated_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        onupdate=func.now(),
        nullable=True,
        comment="Timestamp when record was last updated"
    )


# ============================================================================
# Application Models
# ============================================================================

class Video(UUIDPrimaryKeyMixin, TimestampMixin, Base):
    """
    Video metadata and tracking table.

    Stores YouTube video information and processing status.
    One video can have multiple processing results (different processing runs).
    """
    __tablename__ = "videos"

    # YouTube identification
    video_id: Mapped[str] = mapped_column(
        String(20),
        unique=True,
        index=True,
        nullable=False,
        comment="YouTube video ID (e.g., 'jNQXAC9IVRw')"
    )

    video_url: Mapped[str] = mapped_column(
        String(500),
        nullable=False,
        comment="Full YouTube video URL"
    )

    # Video metadata
    title: Mapped[str] = mapped_column(
        String(500),
        nullable=False,
        comment="Video title from YouTube"
    )

    channel_name: Mapped[Optional[str]] = mapped_column(
        String(200),
        nullable=True,
        comment="YouTube channel name"
    )

    duration: Mapped[Optional[int]] = mapped_column(
        Integer,
        nullable=True,
        comment="Video duration in seconds"
    )

    # Processing tracking
    times_processed: Mapped[int] = mapped_column(
        Integer,
        default=0,
        server_default="0",
        nullable=False,
        comment="Number of times this video has been processed"
    )

    last_processed_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
        comment="Timestamp of most recent processing"
    )

    def __repr__(self) -> str:
        return f"<Video(id={self.id}, video_id='{self.video_id}', title='{self.title[:50]}...')>"


class ProcessingResult(UUIDPrimaryKeyMixin, TimestampMixin, Base):
    """
    Multi-agent processing results table.

    Stores the complete output from multi-agent video processing,
    including lecture notes, extracted AI tools, and execution metadata.
    """
    __tablename__ = "processing_results"

    # Foreign key to Video (stored as UUID)
    video_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        nullable=False,
        index=True,
        comment="Reference to videos.id (not YouTube video_id)"
    )

    # Transcript data
    transcript_text: Mapped[str] = mapped_column(
        Text,
        nullable=False,
        comment="Full transcript extracted from video"
    )

    transcript_length: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
        comment="Character count of transcript"
    )

    # Agent 2 output: Lecture notes (Gemini 2.5 Flash)
    lecture_notes: Mapped[str] = mapped_column(
        Text,
        nullable=False,
        comment="Markdown-formatted lecture notes generated by Gemini"
    )

    # Agent 3 output: AI tools (GPT-4o-mini)
    ai_tools: Mapped[dict] = mapped_column(
        JSON,
        nullable=False,
        comment="JSON array of AI tools extracted by GPT-4o-mini"
    )

    ai_tools_count: Mapped[int] = mapped_column(
        Integer,
        default=0,
        nullable=False,
        comment="Number of AI tools extracted"
    )

    # Processing metadata
    processing_time_seconds: Mapped[float] = mapped_column(
        nullable=False,
        comment="Total processing time in seconds"
    )

    agent_execution_order: Mapped[list] = mapped_column(
        JSON,
        nullable=False,
        comment="Ordered list of agent execution (for debugging)"
    )

    # LangGraph thread ID for checkpointing
    langgraph_thread_id: Mapped[Optional[str]] = mapped_column(
        String(100),
        nullable=True,
        index=True,
        comment="LangGraph thread ID for state persistence"
    )

    def __repr__(self) -> str:
        return f"<ProcessingResult(id={self.id}, video_id={self.video_id}, tools_count={self.ai_tools_count})>"
